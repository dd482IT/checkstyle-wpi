///////////////////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code and other text files for adherence to a set of rules.
// Copyright (C) 2001-2023 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
///////////////////////////////////////////////////////////////////////////////////////////////
package com.puppycrawl.tools.checkstyle.checks.coding;

import java.util.Deque;
import java.util.LinkedList;
import com.puppycrawl.tools.checkstyle.FileStatefulCheck;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.ScopeUtil;

/**
 * <p>
 * Abstract class for checking that an overriding method with no parameters
 * invokes the super method.
 * </p>
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.framework.util.PurityChecker")
public abstract class AbstractSuperCheck extends AbstractCheck {

    /**
     * A key is pointing to the warning message text in "messages.properties"
     * file.
     */
    public static final  String MSG_KEY = "missing.super.call";

    /**
     * Stack of methods.
     */
    private final  Deque<MethodNode> methodStack = new LinkedList<>();

    /**
     * Returns the name of the overriding method.
     *
     * @return the name of the overriding method.
     */
    @org.checkerframework.dataflow.qual.Pure
    protected abstract  String getMethodName( AbstractSuperCheck this);

    @org.checkerframework.dataflow.qual.Pure
    public   int  [] getAcceptableTokens( AbstractSuperCheck this) {
        return getRequiredTokens();
    }

    @org.checkerframework.dataflow.qual.Pure
    public   int  [] getDefaultTokens( AbstractSuperCheck this) {
        return getRequiredTokens();
    }

    @org.checkerframework.dataflow.qual.Pure
    public   int  [] getRequiredTokens( AbstractSuperCheck this) {
        return new int[] { TokenTypes.METHOD_DEF, TokenTypes.LITERAL_SUPER };
    }

    public void beginTree( AbstractSuperCheck this,  DetailAST rootAST) {
        methodStack.clear();
    }

    public void visitToken( AbstractSuperCheck this,  DetailAST ast) {
        if (isOverridingMethod(ast)) {
            methodStack.add(new MethodNode(ast));
        } else if (isSuperCall(ast)) {
            final MethodNode methodNode = methodStack.getLast();
            methodNode.setCallingSuper();
        }
    }

    /**
     * Determines whether a 'super' literal is a call to the super method
     * for this check.
     *
     * @param literalSuperAst the AST node of a 'super' literal.
     * @return true if ast is a call to the super method for this check.
     */
    @org.checkerframework.dataflow.qual.Pure
    private   boolean isSuperCall( AbstractSuperCheck this,  DetailAST literalSuperAst) {
        boolean superCall = false;
        if (!isSameNameMethod(literalSuperAst)) {
            final DetailAST parent = literalSuperAst.getParent();
            if (parent.getType() == TokenTypes.METHOD_REF || !hasArguments(parent)) {
                superCall = isSuperCallInOverridingMethod(parent);
            }
        }
        return superCall;
    }

    /**
     * Determines whether a super call in overriding method.
     *
     * @param ast The AST node of a 'dot operator' in 'super' call.
     * @return true if super call in overriding method.
     */
    @org.checkerframework.dataflow.qual.Pure
    private   boolean isSuperCallInOverridingMethod( AbstractSuperCheck this,  DetailAST ast) {
        boolean inOverridingMethod = false;
        DetailAST dotAst = ast;
        while (dotAst.getType() != TokenTypes.CTOR_DEF && dotAst.getType() != TokenTypes.INSTANCE_INIT) {
            if (dotAst.getType() == TokenTypes.METHOD_DEF) {
                inOverridingMethod = isOverridingMethod(dotAst);
                break;
            }
            dotAst = dotAst.getParent();
        }
        return inOverridingMethod;
    }

    /**
     * Does method have any arguments.
     *
     * @param methodCallDotAst DOT DetailAST
     * @return true if any parameters found
     */
    @org.checkerframework.dataflow.qual.Pure
    private static   boolean hasArguments( DetailAST methodCallDotAst) {
        final DetailAST argumentsList = methodCallDotAst.getNextSibling();
        return argumentsList.hasChildren();
    }

    /**
     * Is same name of method.
     *
     * @param ast method AST
     * @return true if method name is the same
     */
    @org.checkerframework.dataflow.qual.Pure
    private   boolean isSameNameMethod( AbstractSuperCheck this,  DetailAST ast) {
        DetailAST sibling = ast.getNextSibling();
        // ignore type parameters
        if (sibling != null && sibling.getType() == TokenTypes.TYPE_ARGUMENTS) {
            sibling = sibling.getNextSibling();
        }
        return sibling == null || !getMethodName().equals(sibling.getText());
    }

    public void leaveToken( AbstractSuperCheck this,  DetailAST ast) {
        if (isOverridingMethod(ast)) {
            final MethodNode methodNode = methodStack.removeLast();
            if (!methodNode.isCallingSuper()) {
                final DetailAST methodAST = methodNode.getMethod();
                final DetailAST nameAST = methodAST.findFirstToken(TokenTypes.IDENT);
                log(nameAST, MSG_KEY, nameAST.getText());
            }
        }
    }

    /**
     * Determines whether an AST is a method definition for this check,
     * without any parameters.
     *
     * @param ast the method definition AST.
     * @return true if the method of ast is a method for this check.
     */
    @org.checkerframework.dataflow.qual.Pure
    private   boolean isOverridingMethod( AbstractSuperCheck this,  DetailAST ast) {
        boolean overridingMethod = false;
        if (ast.getType() == TokenTypes.METHOD_DEF && !ScopeUtil.isInInterfaceOrAnnotationBlock(ast)) {
            final DetailAST nameAST = ast.findFirstToken(TokenTypes.IDENT);
            final String name = nameAST.getText();
            final DetailAST modifiersAST = ast.findFirstToken(TokenTypes.MODIFIERS);
            if (getMethodName().equals(name) && modifiersAST.findFirstToken(TokenTypes.LITERAL_NATIVE) == null) {
                final DetailAST params = ast.findFirstToken(TokenTypes.PARAMETERS);
                overridingMethod = !params.hasChildren();
            }
        }
        return overridingMethod;
    }

    /**
     * Stack node for a method definition and a record of
     * whether the method has a call to the super method.
     */
    private static final class MethodNode {

        /**
         * Method definition.
         */
        private final  DetailAST method;

        /**
         * True if the overriding method calls the super method.
         */
        private   boolean callingSuper;

        /**
         * Constructs a stack node for a method definition.
         *
         * @param ast AST for the method definition.
         */
        private MethodNode( DetailAST ast) {
            method = ast;
            callingSuper = false;
        }

        /**
         * Records that the overriding method has a call to the super method.
         */
        public void setCallingSuper( MethodNode this) {
            callingSuper = true;
        }

        /**
         * Determines whether the overriding method has a call to the super
         * method.
         *
         * @return true if the overriding method has a call to the super method.
         */
        @org.checkerframework.dataflow.qual.Pure
        public   boolean isCallingSuper( MethodNode this) {
            return callingSuper;
        }

        /**
         * Returns the overriding method definition AST.
         *
         * @return the overriding method definition AST.
         */
        @org.checkerframework.dataflow.qual.Pure
        public  DetailAST getMethod( MethodNode this) {
            return method;
        }
    }
}
