///////////////////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code and other text files for adherence to a set of rules.
// Copyright (C) 2001-2023 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
///////////////////////////////////////////////////////////////////////////////////////////////
package com.puppycrawl.tools.checkstyle;

import java.util.BitSet;
import java.util.Collections;
import java.util.List;
import org.antlr.v4.runtime.Token;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.utils.TokenUtil;

/**
 * The implementation of {@link DetailAST}. This should only be directly used to
 * create custom AST nodes and in 'JavaAstVisitor.java'.
 *
 * @noinspection FieldNotUsedInToString
 * @noinspectionreason FieldNotUsedInToString - We require a specific string format for
 *      printing to CLI.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.common.value.ValueChecker")
public final class DetailAstImpl implements DetailAST {

    /**
     * Constant to indicate if not calculated the child count.
     */
    private static final  @org.checkerframework.common.value.qual.IntVal({ -2147483648L }) int NOT_INITIALIZED = Integer.MIN_VALUE;

    /**
     * The line number. *
     */
    private   int lineNo = NOT_INITIALIZED;

    /**
     * The column number. *
     */
    private   int columnNo = NOT_INITIALIZED;

    /**
     * Number of children.
     */
    private  @org.checkerframework.common.value.qual.IntRange(from = -2147483648L, to = 2147483647L) int childCount = NOT_INITIALIZED;

    /**
     * The parent token.
     */
    private  DetailAstImpl parent;

    /**
     * Previous sibling.
     */
    private  DetailAstImpl previousSibling;

    /**
     * First child of this DetailAST.
     */
    private  DetailAstImpl firstChild;

    /**
     * First sibling of this DetailAST.
     */
    private  DetailAstImpl nextSibling;

    /**
     * Text of this DetailAST.
     */
    private  String text;

    /**
     * The type of this DetailAST.
     */
    private   int type;

    /**
     * All tokens on COMMENTS channel to the left of the current token up to the
     * preceding token on the DEFAULT_TOKEN_CHANNEL.
     */
    private  List<Token> hiddenBefore;

    /**
     * All tokens on COMMENTS channel to the right of the current token up to the
     * next token on the DEFAULT_TOKEN_CHANNEL.
     */
    private  List<Token> hiddenAfter;

    /**
     * All token types in this branch.
     * Token 'x' (where x is an int) is in this branch
     * if branchTokenTypes.get(x) is true.
     */
    private  BitSet branchTokenTypes;

    /**
     * Initializes this DetailAstImpl.
     *
     * @param tokenType the type of this DetailAstImpl
     * @param tokenText the text of this DetailAstImpl
     */
    public void initialize( DetailAstImpl this,  @org.checkerframework.common.value.qual.IntVal({ 145L, 182L }) int tokenType, @org.checkerframework.common.value.qual.StringVal({ "*/", "/*" }) String tokenText) {
        type = tokenType;
        text = tokenText;
    }

    /**
     * Initializes this DetailAstImpl.
     *
     * @param token the token to generate this DetailAstImpl from
     */
    public void initialize( DetailAstImpl this,  Token token) {
        text = token.getText();
        type = token.getType();
        lineNo = token.getLine();
        columnNo = token.getCharPositionInLine();
    }

    /**
     * Add previous sibling.
     *
     * @param ast
     *        DetailAST object.
     */
    public void addPreviousSibling( DetailAstImpl this,  DetailAST ast) {
        clearBranchTokenTypes();
        clearChildCountCache(parent);
        if (ast != null) {
            // parent is set in setNextSibling or parent.setFirstChild
            final DetailAstImpl previousSiblingNode = previousSibling;
            final DetailAstImpl astImpl = (DetailAstImpl) ast;
            if (previousSiblingNode != null) {
                astImpl.previousSibling = previousSiblingNode;
                previousSiblingNode.setNextSibling(astImpl);
            } else if (parent != null) {
                parent.setFirstChild(astImpl);
            }
            astImpl.setNextSibling(this);
            previousSibling = astImpl;
        }
    }

    /**
     * Add next sibling, pushes other siblings back.
     *
     * @param ast DetailAST object.
     */
    public void addNextSibling( DetailAstImpl this,  DetailAST ast) {
        clearBranchTokenTypes();
        clearChildCountCache(parent);
        if (ast != null) {
            // parent is set in setNextSibling
            final DetailAstImpl sibling = nextSibling;
            final DetailAstImpl astImpl = (DetailAstImpl) ast;
            if (sibling != null) {
                astImpl.setNextSibling(sibling);
                sibling.previousSibling = astImpl;
            }
            astImpl.previousSibling = this;
            setNextSibling(astImpl);
        }
    }

    /**
     * Adds a new child to the current AST.
     *
     * @param child to DetailAST to add as child
     */
    public void addChild( DetailAstImpl this,  DetailAST child) {
        clearBranchTokenTypes();
        clearChildCountCache(this);
        if (child != null) {
            final DetailAstImpl astImpl = (DetailAstImpl) child;
            astImpl.setParent(this);
            astImpl.previousSibling = (DetailAstImpl) getLastChild();
        }
        DetailAST temp = firstChild;
        if (temp == null) {
            firstChild = (DetailAstImpl) child;
        } else {
            while (temp.getNextSibling() != null) {
                temp = temp.getNextSibling();
            }
            ((DetailAstImpl) temp).setNextSibling(child);
        }
    }

    public  @org.checkerframework.common.value.qual.IntRange(from = -2147483648L, to = 2147483647L) int getChildCount( DetailAstImpl this) {
        // lazy init
        if (childCount == NOT_INITIALIZED) {
            childCount = 0;
            DetailAST child = firstChild;
            while (child != null) {
                childCount += 1;
                child = child.getNextSibling();
            }
        }
        return childCount;
    }

    @org.checkerframework.dataflow.qual.Pure
    public   int getChildCount( DetailAstImpl this,  @org.checkerframework.common.value.qual.IntVal({ 17L, 21L, 28L, 160L }) int tokenType) {
        int count = 0;
        for (DetailAST ast = firstChild; ast != null; ast = ast.getNextSibling()) {
            if (ast.getType() == tokenType) {
                count++;
            }
        }
        return count;
    }

    /**
     * Set the parent token.
     *
     * @param parent the parent token
     */
    private void setParent( DetailAstImpl this,  DetailAstImpl parent) {
        DetailAstImpl instance = this;
        do {
            instance.clearBranchTokenTypes();
            instance.parent = parent;
            instance = instance.nextSibling;
        } while (instance != null);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  DetailAST getParent( DetailAstImpl this) {
        return parent;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  String getText( DetailAstImpl this) {
        return text;
    }

    /**
     * Sets the text for this DetailAstImpl.
     *
     * @param text the text field of this DetailAstImpl
     */
    public void setText( DetailAstImpl this,  String text) {
        this.text = text;
    }

    @org.checkerframework.dataflow.qual.Pure
    public   int getType( DetailAstImpl this) {
        return type;
    }

    /**
     * Sets the type of this AST.
     *
     * @param type the token type of this DetailAstImpl
     */
    public void setType( DetailAstImpl this,   int type) {
        this.type = type;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.common.value.qual.IntRange(from = -2147483648L, to = 2147483647L) int getLineNo( DetailAstImpl this) {
        int resultNo = -1;
        if (lineNo == NOT_INITIALIZED) {
            // an inner AST that has been initialized
            // with initialize(String text)
            resultNo = findLineNo(firstChild);
            if (resultNo == -1) {
                resultNo = findLineNo(nextSibling);
            }
        }
        if (resultNo == -1) {
            resultNo = lineNo;
        }
        return resultNo;
    }

    /**
     * Set line number.
     *
     * @param lineNo
     *        line number.
     */
    public void setLineNo( DetailAstImpl this,   int lineNo) {
        this.lineNo = lineNo;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.common.value.qual.IntRange(from = -2147483648L, to = 2147483647L) int getColumnNo( DetailAstImpl this) {
        int resultNo = -1;
        if (columnNo == NOT_INITIALIZED) {
            // an inner AST that has been initialized
            // with initialize(String text)
            resultNo = findColumnNo(firstChild);
            if (resultNo == -1) {
                resultNo = findColumnNo(nextSibling);
            }
        }
        if (resultNo == -1) {
            resultNo = columnNo;
        }
        return resultNo;
    }

    /**
     * Set column number.
     *
     * @param columnNo
     *        column number.
     */
    public void setColumnNo( DetailAstImpl this,   int columnNo) {
        this.columnNo = columnNo;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  DetailAST getLastChild( DetailAstImpl this) {
        DetailAstImpl ast = firstChild;
        while (ast != null && ast.nextSibling != null) {
            ast = ast.nextSibling;
        }
        return ast;
    }

    /**
     * Finds column number in the first non-comment node.
     *
     * @param ast DetailAST node.
     * @return Column number if non-comment node exists, -1 otherwise.
     */
    @org.checkerframework.dataflow.qual.Pure
    private static  @org.checkerframework.common.value.qual.IntRange(from = -2147483648L, to = 2147483647L) int findColumnNo( DetailAST ast) {
        int resultNo = -1;
        DetailAST node = ast;
        while (node != null) {
            // comment node can't be start of any java statement/definition
            if (TokenUtil.isCommentType(node.getType())) {
                node = node.getNextSibling();
            } else {
                resultNo = node.getColumnNo();
                break;
            }
        }
        return resultNo;
    }

    /**
     * Finds line number in the first non-comment node.
     *
     * @param ast DetailAST node.
     * @return Line number if non-comment node exists, -1 otherwise.
     */
    @org.checkerframework.dataflow.qual.Pure
    private static  @org.checkerframework.common.value.qual.IntRange(from = -2147483648L, to = 2147483647L) int findLineNo( DetailAST ast) {
        int resultNo = -1;
        DetailAST node = ast;
        while (node != null) {
            // comment node can't be start of any java statement/definition
            if (TokenUtil.isCommentType(node.getType())) {
                node = node.getNextSibling();
            } else {
                resultNo = node.getLineNo();
                break;
            }
        }
        return resultNo;
    }

    /**
     * Returns token type with branch.
     *
     * @return the token types that occur in the branch as a sorted set.
     */
    private  BitSet getBranchTokenTypes( DetailAstImpl this) {
        // lazy init
        if (branchTokenTypes == null) {
            branchTokenTypes = new BitSet();
            branchTokenTypes.set(type);
            // add union of all children
            DetailAstImpl child = firstChild;
            while (child != null) {
                final BitSet childTypes = child.getBranchTokenTypes();
                branchTokenTypes.or(childTypes);
                child = child.nextSibling;
            }
        }
        return branchTokenTypes;
    }

    public   boolean branchContains( DetailAstImpl this,   int tokenType) {
        return getBranchTokenTypes().get(tokenType);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  DetailAST getPreviousSibling( DetailAstImpl this) {
        return previousSibling;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  DetailAST findFirstToken( DetailAstImpl this,   int tokenType) {
        DetailAST returnValue = null;
        for (DetailAST ast = firstChild; ast != null; ast = ast.getNextSibling()) {
            if (ast.getType() == tokenType) {
                returnValue = ast;
                break;
            }
        }
        return returnValue;
    }

    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.common.value.qual.ArrayLenRange(from = 5, to = 2147483647) String toString( DetailAstImpl this) {
        return text + "[" + getLineNo() + "x" + getColumnNo() + "]";
    }

    @org.checkerframework.dataflow.qual.Pure
    public  DetailAstImpl getNextSibling( DetailAstImpl this) {
        return nextSibling;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  DetailAstImpl getFirstChild( DetailAstImpl this) {
        return firstChild;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.common.value.qual.IntRange(from = -2147483648L, to = 2147483647L) int getNumberOfChildren( DetailAstImpl this) {
        return getChildCount();
    }

    @org.checkerframework.dataflow.qual.Pure
    public   boolean hasChildren( DetailAstImpl this) {
        return firstChild != null;
    }

    /**
     * Clears the child count for the ast instance.
     *
     * @param ast The ast to clear.
     */
    private static void clearChildCountCache( DetailAstImpl ast) {
        if (ast != null) {
            ast.childCount = NOT_INITIALIZED;
        }
    }

    /**
     * Clears branchTokenTypes cache for all parents of the current DetailAST instance, and the
     * child count for the current DetailAST instance.
     */
    private void clearBranchTokenTypes( DetailAstImpl this) {
        DetailAstImpl prevParent = parent;
        while (prevParent != null) {
            prevParent.branchTokenTypes = null;
            prevParent = prevParent.parent;
        }
    }

    /**
     * Sets the next sibling of this AST.
     *
     * @param nextSibling the DetailAST to set as sibling
     */
    public void setNextSibling( DetailAstImpl this,  DetailAST nextSibling) {
        clearBranchTokenTypes();
        clearChildCountCache(parent);
        this.nextSibling = (DetailAstImpl) nextSibling;
        if (nextSibling != null && parent != null) {
            ((DetailAstImpl) nextSibling).setParent(parent);
        }
        if (nextSibling != null) {
            ((DetailAstImpl) nextSibling).previousSibling = this;
        }
    }

    /**
     * Sets the first child of this AST.
     *
     * @param firstChild the DetailAST to set as first child
     */
    public void setFirstChild( DetailAstImpl this,  DetailAST firstChild) {
        clearBranchTokenTypes();
        clearChildCountCache(this);
        this.firstChild = (DetailAstImpl) firstChild;
        if (firstChild != null) {
            ((DetailAstImpl) firstChild).setParent(this);
        }
    }

    /**
     * Removes all children of this AST.
     */
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.firstChild" }, qualifier = org.checkerframework.common.value.qual.BottomVal.class)
    public void removeChildren() {
        firstChild = null;
    }

    /**
     * Get list of tokens on COMMENTS channel to the left of the
     * current token up to the preceding token on the DEFAULT_TOKEN_CHANNEL.
     *
     * @return list of comment tokens
     */
    public  List<Token> getHiddenBefore( DetailAstImpl this) {
        List<Token> returnList = null;
        if (hiddenBefore != null) {
            returnList = Collections.unmodifiableList(hiddenBefore);
        }
        return returnList;
    }

    /**
     * Get list tokens on COMMENTS channel to the right of the current
     * token up to the next token on the DEFAULT_TOKEN_CHANNEL.
     *
     * @return list of comment tokens
     */
    public  List<Token> getHiddenAfter( DetailAstImpl this) {
        List<Token> returnList = null;
        if (hiddenAfter != null) {
            returnList = Collections.unmodifiableList(hiddenAfter);
        }
        return returnList;
    }

    /**
     * Sets the hiddenBefore token field.
     *
     * @param hiddenBefore comment token preceding this DetailAstImpl
     */
    public void setHiddenBefore( DetailAstImpl this,  List<Token> hiddenBefore) {
        this.hiddenBefore = Collections.unmodifiableList(hiddenBefore);
    }

    /**
     * Sets the hiddenAfter token field.
     *
     * @param hiddenAfter comment token following this DetailAstImpl
     */
    public void setHiddenAfter( DetailAstImpl this,  List<Token> hiddenAfter) {
        this.hiddenAfter = Collections.unmodifiableList(hiddenAfter);
    }
}
